/*******************************************************************************
*
* Copyright 2017 SAP SE
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You should have received a copy of the License along with this
* program. If not, you may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*******************************************************************************/

package reports

import (
	"fmt"
	"net/http"
	"regexp"
	"slices"
	"strings"

	"github.com/sapcc/go-api-declarations/limes"
	limesresources "github.com/sapcc/go-api-declarations/limes/resources"
	"golang.org/x/exp/maps"

	"github.com/sapcc/limes/internal/core"
	"github.com/sapcc/limes/internal/db"
)

// Filter describes query parameters that can be sent to various GET endpoints
// to filter the reports generated by this package.
type Filter struct {
	// fully populated set of included services and resources
	Includes map[limes.ServiceType]map[limesresources.ResourceName]bool
	// whether we need to apply filters on service_type and resource_name in DB queries
	ServiceTypeIsFiltered  bool
	ResourceNameIsFiltered bool

	WithSubresources  bool
	WithSubcapacities bool
	WithAZBreakdown   bool

	IsSubcapacityAllowed func(serviceType limes.ServiceType, resourceName limesresources.ResourceName) bool
}

// ReadFilter extracts a Filter from the given Request.
func ReadFilter(r *http.Request, cluster *core.Cluster) Filter {
	queryValues := r.URL.Query()
	apiServiceTypes := apiFilter(queryValues["service"])
	apiResourceNames := apiFilter(queryValues["resource"])
	apiAreas := apiFilter(queryValues["area"])
	_, withDetail := queryValues["detail"]

	f := Filter{
		Includes:               make(map[limes.ServiceType]map[limesresources.ResourceName]bool, len(cluster.QuotaPlugins)),
		ServiceTypeIsFiltered:  (len(apiServiceTypes) + len(apiAreas)) > 0,
		ResourceNameIsFiltered: len(apiResourceNames) > 0,
		WithSubresources:       withDetail,
		WithSubcapacities:      withDetail,
		WithAZBreakdown:        strings.Contains(r.Header.Get("X-Limes-V2-API-Preview"), "per-az"),
	}

	// NOTE: `serviceType` and `resourceName` are *internal* identifiers, so
	// we cannot check those against the query filters directly. The query
	// filters apply to the identifiers in `apiIdentity`.
	for serviceType, quotaPlugin := range cluster.QuotaPlugins {
		if !apiAreas.Matches(quotaPlugin.ServiceInfo().Area) {
			continue
		}

		for resourceName := range quotaPlugin.Resources() {
			apiIdentity := cluster.BehaviorForResource(serviceType, resourceName).IdentityInV1API

			if !apiServiceTypes.Matches(string(apiIdentity.ServiceType)) {
				continue
			}

			if f.Includes[serviceType] == nil {
				f.Includes[serviceType] = make(map[limesresources.ResourceName]bool)
			}
			f.Includes[serviceType][resourceName] = apiResourceNames.Matches(string(apiIdentity.ResourceName))
		}
	}

	// by default, all subcapacities can be included, but the caller can restrict this based on AuthZ
	f.IsSubcapacityAllowed = func(limes.ServiceType, limesresources.ResourceName) bool { return true }

	return f
}

type apiFilter []string

func (a apiFilter) Matches(value string) bool {
	// A list filter from the URL query can either:
	// - be empty and match all possible values, or
	// - be non-empty and match the listed values.
	return len(a) == 0 || slices.Contains(a, value)
}

var filterPrepareRx = regexp.MustCompile(`{{AND ([a-z._]+) = \$(service_type|resource_name)}}`)

// PrepareQuery takes a SQL query string, and replaces the following
// placeholders with the values in this Filter:
//
//	{{AND some_table.some_field = $service_type}}
//	{{AND some_table.some_field = $resource_name}}
//
// Note that, because of support for API-level resource renaming, this is only
// a best-effort filtering. For example, suppose that we have resources called
// "foo/capacity" and "bar/capacity", but the latter is renamed in the API to
// "bar/some_capacity". A query for "?resource=capacity" should only yield
// "foo/capacity", but a DB query with "WHERE resource_name = 'capacity'" will
// also yield "bar/some_capacity".
//
// Therefore (and also because the DB may contain left-over entries from
// obsolete services or resources), results from a query prepared with this
// function must be rechecked against the Filter.Includes map.
func (f Filter) PrepareQuery(query string) (preparedQuery string, args []any) {
	preparedQuery = filterPrepareRx.ReplaceAllStringFunc(query, func(matchStr string) string {
		match := filterPrepareRx.FindStringSubmatch(matchStr)

		var values []string
		switch match[2] {
		case "service_type":
			if !f.ServiceTypeIsFiltered {
				return ""
			}
			for serviceType := range f.Includes {
				values = append(values, string(serviceType))
			}

		case "resource_name":
			if !f.ResourceNameIsFiltered {
				return ""
			}
			isValue := make(map[string]struct{})
			for _, includesInService := range f.Includes {
				for resName, included := range includesInService {
					if included {
						isValue[string(resName)] = struct{}{}
					}
				}
			}
			values = maps.Keys(isValue)

		default:
			panic(fmt.Sprintf("unreachable: matchStr = %q", matchStr))
		}

		whereStr, queryArgs := db.BuildSimpleWhereClause(map[string]any{match[1]: values}, len(args))
		args = append(args, queryArgs...)
		return "AND " + whereStr
	})

	return
}
